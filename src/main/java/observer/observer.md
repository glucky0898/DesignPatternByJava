# 观察者定义
 1. 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个主题(目标对象)被修改时，所有依赖于它的对象都得到通知并被自动更新。观察者模式属于行为型模式。
 2. 何时使用：一个主题的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。
 3. 关键代码：在抽象类里有一个ArrayList存放观察者们。
 4. 优点：观察者和被观察者是抽象耦合的。 2、建立一套触发机制。  
    缺点：观察者较多时，比较耗事件、若观察者和主题事件有循环依赖会导致系统崩溃、观察者对象只知道主题发生了变化，具体发生了什么变化并不知道。
 
# Weather
 ## bad_design
   缺点如下：  
   1. 每个观察者面向具体实现类编程，而不是接口。
   2. 当有新的观察者加入或者删除旧的观察者时，无法动态添加、删除，都得修改主题对象WeatherData。即未封装变化的部分。
   3. 当主题对象的成员属性变化时，都得修改update方法的参数。
 ## optimal_design
   优点如下：   
   1. 将变化和固定不变部分分离。在观察模式中，变化的部分是主题的属性、观察者的类型和数量。将他们分离出来，可以改变主题的属性、观察者的类型和数量时，不比改变主题。
   2. 分离的方式时，面向接口编程以及多用组合。主题和观察者都实现了其相应的接口。观察者通过Observer向Subject注册，Subject不需要关心观察者的具体实现以及update的具体方法，只需要调用Observer的update方法即可完成推送服务。观察者则利用Subject接口将自身注册到主题中，而不需要关心主题的具体类型以及注册方式。主题和观察者之间松耦合。  
   3. 另一方面展示方法也面向接口DisplayElement。当有新的展示方式的需求增加时，必须implement DisplayElement接口，强制用户完成display方法的实现,避免需求出错。
# drawlots
 需求：模拟摇号过程，将摇号的结果通过短信发送给客户以及MQ记录摇号结果。  
 主流程：获取摇号结果(主题)  辅流程：短信、MQ(观察者)
 ## bad_design 
   缺点如下：
   1. 主流程和辅流程放在一个方法中实现，没有区分开
   2. 当业务扩展时，辅助链路可能会不断补充和调整。没有将这部分变化的部分进行封装，辅流程硬编码到主流程方法中，耦合度高，导致不易扩展和维护。
 ## optimal_design
   优点如下：
   1. 面向接口编程，将所有的发送消息的类都继承同一个接口EventListener，并增加了EventManager事件管理类，通过EventManager对观察者进行统一管理(注册、删除、发送消息等)。
   2. DrawLotsService定义为抽象类，将主事件和辅事件分开定义在不同方法中。其中辅事件具体实现在抽象类中完成。主事件为抽象方法，子类必须实现主事件方法。以此将辅助流程中的事件监听、通知过程屏蔽，开发者只需要专注实现摇号的生成这一主流程。
   3. 使用枚举定义了事件的类型，防止外部用户乱传信息。
   4. 设计模式符合开闭原则。当有需要添加或修改监听事件时，不需要改动EventManager以及DrawLotsServiceImpl的方法。只需要将新监听器注册进去或者修改监听器的监听操作即可。易于扩展和维护。